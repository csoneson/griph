# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Hellinger distance between columns of a matrix.
#'
#' @description
#' \code{HellingerMat} returns a matrix of Hellinger distances between
#' the columns of the matrix passed as argument.
#'
#' @details
#' This function calculates the Hellinger distances between columns of the matrix
#' given as argument. It is implemented in C++ for efficiency. For an argument
#' matrix with r rows and c columns, the return value is an c-by-c matrix with
#' all pairwise distances.
#'
#' @param A Numeric matrix.
#'
#' @return A square matrix of dimensions \code{ncol(A})-by-\code{ncol(A)}.
#'
#' @examples
#' x <- matrix(1:12, nrow=3, ncol=4)
#' HellingerMat(x)
#'
HellingerMat <- function(A) {
    .Call(griph_HellingerMat, A)
}

#' @title Jensen-Shannon divergence between columns of a matrix.
#'
#' @description
#' \code{JSDmat} returns a matrix of Jensen-Shannon divergences between the columns
#' of the matrix passed as argument.
#'
#' @details
#' This function calculates the Jensen-Shannon divergences between columns of the matrix
#' given as argument. It is implemented in C++ for efficiency. For an argument
#' matrix with r rows and c columns, the return value is an c-by-c matrix with
#' all pairwise distances.
#'
#' @param A Numeric matrix.
#'
#' @return A square matrix of dimensions \code{ncol(A})-by-\code{ncol(A)}.
#'
#' @examples
#' x <- matrix(1:12, nrow=3, ncol=4)
#' JSDmat(x)
#'
JSDmat <- function(A) {
    .Call(griph_JSDmat, A)
}

#' @title Canberra distance between columns of two matrices.
#'
#' @description
#' \code{CanberraMat} returns a matrix of Canberra distances between
#' the columns of the matrix passed as argument.
#'
#' @details
#' This function calculates the Canberra distances between the columns of two matrices
#' given as argument. It is implemented in C++ for efficiency. For two argument
#' matrices with the same number of r rows and c1 , c2 columns, the return value is an c1-by-c2 matrix with
#' the pairwise c1i c2j distances.
#'
#' @param A  Numeric matrix (variables by features)
#' @param B  Numeric matrix (variables by features)
#'
#' @return A matrix of dimensions \code{ncol(A})-by-\code{ncol(B)}.
#'
#' @examples
#' x <- matrix(1:12, nrow=3, ncol=4)
#' y <- matrix(1:12, nrow=3, ncol=5)
#' PHellingerMat(x, y)
#'
PCanberraMat <- function(A, B) {
    .Call(griph_PCanberraMat, A, B)
}

#' @title Hellinger distance between columns of two matrices.
#'
#' @description
#' \code{HellingerMat} returns a matrix of Hellinger distances between
#' the columns of the matrix passed as argument.
#'
#' @details
#' This function calculates the Hellinger distances between the columns of two matrices
#' given as argument. It is implemented in C++ for efficiency. For two argument
#' matrices with the same number of r rows and c1 , c2 columns, the return value is an c1-by-c2 matrix with
#' the pairwise c1i c2j distances.
#'
#' @param A  Numeric matrix (variables by features)
#' @param B  Numeric matrix (variables by features)
#'
#' @return A matrix of dimensions \code{ncol(A})-by-\code{ncol(B)}.
#'
#' @examples
#' x <- matrix(1:12, nrow=3, ncol=4)
#' y <- matrix(1:12, nrow=3, ncol=5)
#' PHellingerMat(x, y)
#'
PHellingerMat <- function(A, B) {
    .Call(griph_PHellingerMat, A, B)
}

checkBits <- function() {
    .Call(griph_checkBits)
}

checkOpenMP <- function() {
    .Call(griph_checkOpenMP)
}

searchTrees <- function(threshold, n_trees, K, maxIter, data, distMethod, seed, threads, verbose) {
    .Call(griph_searchTrees, threshold, n_trees, K, maxIter, data, distMethod, seed, threads, verbose)
}

fastDistance <- function(is, js, data, distMethod, threads, verbose) {
    .Call(griph_fastDistance, is, js, data, distMethod, threads, verbose)
}

fastCDistance <- function(is, js, i_locations, p_locations, x, distMethod, threads, verbose) {
    .Call(griph_fastCDistance, is, js, i_locations, p_locations, x, distMethod, threads, verbose)
}

fastSDistance <- function(is, js, i_locations, j_locations, x, distMethod, threads, verbose) {
    .Call(griph_fastSDistance, is, js, i_locations, j_locations, x, distMethod, threads, verbose)
}

sgd <- function(coords, targets_i, sources_j, ps, weights, gamma, rho, n_samples, M, alpha, momentum, useDegree, seed, threads, verbose) {
    .Call(griph_sgd, coords, targets_i, sources_j, ps, weights, gamma, rho, n_samples, M, alpha, momentum, useDegree, seed, threads, verbose)
}

searchTreesCSparse <- function(threshold, n_trees, K, maxIter, i, p, x, distMethod, seed, threads, verbose) {
    .Call(griph_searchTreesCSparse, threshold, n_trees, K, maxIter, i, p, x, distMethod, seed, threads, verbose)
}

searchTreesTSparse <- function(threshold, n_trees, K, maxIter, i, j, x, distMethod, seed, threads, verbose) {
    .Call(griph_searchTreesTSparse, threshold, n_trees, K, maxIter, i, j, x, distMethod, seed, threads, verbose)
}

